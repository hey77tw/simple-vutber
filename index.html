<!DOCTYPE html>
<html>
<head>
  <title>éŸ³è¨Šè¦–è¦ºåŒ– - VTuber</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: linear-gradient(135deg, #2c3e50 0%, #34495e 30%, #5d4e75 70%, #8b5a3c 100%);
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }
    
    .container {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 0 0 20px 20px;
      padding: 0 30px 30px 30px;
      backdrop-filter: blur(10px);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      text-align: center;
      width: 100%;
      max-width: 900px;
    }
    
    h1 {
      color: white;
      margin-bottom: 20px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    }
    
    #vtuberImage {
      width: 200px;
      height: 200px;
      margin: 0;
      border-radius: 0px;
      transition: transform 0.2s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.15s ease;
      position: relative;
      top: 0;
      transform: scaleX(-1);
      background: black;
    }
    
    #canvas {
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 10px;
      margin: 20px;
      background: rgba(0, 0, 0, 0.3);
    }
    
    button {
      margin: 10px;
      padding: 12px 24px;
      border: none;
      border-radius: 25px;
      background: rgba(255, 255, 255, 0.2);
      color: white;
      cursor: pointer;
      font-size: 16px;
      transition: all 0.3s ease;
    }
    
    button:hover {
      background: rgba(255, 255, 255, 0.3);
      transform: translateY(-2px);
    }
    
    button:disabled {
      background: rgba(255, 255, 255, 0.1);
      cursor: not-allowed;
      transform: none;
    }
    
    #startMic {
      background: rgba(76, 175, 80, 0.7);
    }
    
    #startMic:hover {
      background: rgba(76, 175, 80, 0.9);
    }
    
    #stopMic {
      background: rgba(244, 67, 54, 0.7);
    }
    
    #stopMic:hover {
      background: rgba(244, 67, 54, 0.9);
    }
    
    #testMic {
      background: rgba(255, 193, 7, 0.7);
    }
    
    #testMic:hover {
      background: rgba(255, 193, 7, 0.9);
    }
    
    .status {
      color: white;
      margin: 20px 10px 10px 10px;
      font-size: 18px;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
    }
    
    .controls {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
    }
    
    .volume-control {
      display: flex;
      align-items: center;
      gap: 10px;
      color: white;
      font-size: 16px;
    }
    
    #volumeSlider {
      width: 200px;
      height: 6px;
      border-radius: 3px;
      background: rgba(255, 255, 255, 0.3);
      outline: none;
    }
    
    #volumeSlider::-webkit-slider-thumb {
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #4ecdc4;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
    }
    
    #volumeValue {
      min-width: 30px;
      text-align: center;
      font-weight: bold;
    }
    
    .click-to-start {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 15px;
      padding: 40px;
      margin: 20px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
      border: 2px dashed rgba(255, 255, 255, 0.3);
    }
    
    .click-to-start:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: scale(1.02);
      border-color: rgba(255, 255, 255, 0.5);
    }
    
    .click-to-start h2 {
      color: white;
      margin: 0 0 10px 0;
      font-size: 24px;
    }
    
    .click-to-start p {
      color: rgba(255, 255, 255, 0.8);
      margin: 0;
      font-size: 16px;
    }
    
    /* è¨“ç·´ä»‹é¢æ¨£å¼ */
    .training-section {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 15px;
      padding: 20px;
      margin-top: 20px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .training-controls {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
    }
    
    .mouth-buttons {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      margin: 15px 0;
    }
    
    .mouth-btn {
      padding: 10px 15px;
      border: none;
      border-radius: 20px;
      background: rgba(78, 205, 196, 0.7);
      color: white;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.3s ease;
      font-weight: bold;
      user-select: none;
    }
    
    .mouth-btn:hover {
      background: rgba(78, 205, 196, 0.9);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(78, 205, 196, 0.3);
    }
    
    .mouth-btn:active {
      transform: translateY(0);
      background: rgba(78, 205, 196, 1);
    }
    
    .mouth-btn.pressed {
      background: rgba(255, 107, 107, 0.9);
      transform: scale(0.95);
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
      animation: pulse 1s infinite;
    }
    
    .mouth-btn.recording {
      background: rgba(76, 175, 80, 0.8);
      animation: flash 0.5s ease;
    }
    
    @keyframes pulse {
      0% { opacity: 0.8; }
      50% { opacity: 1; }
      100% { opacity: 0.8; }
    }
    
    @keyframes flash {
      0% { background: rgba(76, 175, 80, 0.8); }
      50% { background: rgba(76, 175, 80, 1); }
      100% { background: rgba(76, 175, 80, 0.8); }
    }
    
    #toggleTraining {
      background: rgba(255, 193, 7, 0.7);
    }
    
    #toggleTraining:hover {
      background: rgba(255, 193, 7, 0.9);
    }
    
    #toggleTraining.training-active {
      background: rgba(244, 67, 54, 0.7);
    }
    
    #toggleTraining.training-active:hover {
      background: rgba(244, 67, 54, 0.9);
    }
    
    #saveTrainingData {
      background: rgba(76, 175, 80, 0.7);
    }
    
    #saveTrainingData:hover {
      background: rgba(76, 175, 80, 0.9);
    }
    
    #loadTrainingData {
      background: rgba(156, 39, 176, 0.7);
    }
    
    #loadTrainingData:hover {
      background: rgba(156, 39, 176, 0.9);
    }
    
    /* èƒŒæ™¯è¨­å®šæ¨£å¼ */
    .bg-controls {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    
    .bg-control-row {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }
    
    .bg-style-buttons {
      display: flex;
      gap: 5px;
    }
    
    .bg-style-btn {
      padding: 8px 15px;
      border: none;
      border-radius: 15px;
      background: rgba(255, 255, 255, 0.2);
      color: white;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.3s ease;
      user-select: none;
    }
    
    .bg-style-btn:hover {
      background: rgba(255, 255, 255, 0.3);
      transform: translateY(-1px);
    }
    
    .bg-style-btn.active {
      background: rgba(78, 205, 196, 0.8);
      box-shadow: 0 2px 8px rgba(78, 205, 196, 0.3);
    }
    
    .bg-style-btn.active:hover {
      background: rgba(78, 205, 196, 1);
    }
    
    #resetBgColor {
      background: rgba(255, 193, 7, 0.7);
    }
    
    #resetBgColor:hover {
      background: rgba(255, 193, 7, 0.9);
    }
    
    #bgOpacitySlider {
      height: 6px;
      border-radius: 3px;
      background: rgba(255, 255, 255, 0.3);
      outline: none;
    }
    
    #bgOpacitySlider::-webkit-slider-thumb {
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #4ecdc4;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
    }
  </style>
</head>
<body>
  <div class="container">
    <img id="vtuberImage" src="assets/vtuber-mouth-close.png" alt="VTuber">
    <div class="status" id="status">é»æ“Šä»»ä½•åœ°æ–¹é–‹å§‹ä½¿ç”¨éº¥å…‹é¢¨</div>
    <div id="clickToStart" class="click-to-start">
      <h2>ğŸ¤ é»æ“Šé–‹å§‹èªéŸ³æª¢æ¸¬</h2>
      <p>VTuberæº–å‚™å¥½äº†ï¼</p>
    </div>
    <canvas id="canvas" width="800" height="300" style="display: none;"></canvas>
    <div class="controls" style="display: none;">
      <button id="startMic">é–‹å§‹ä½¿ç”¨éº¥å…‹é¢¨</button>
      <button id="stopMic" disabled>åœæ­¢éº¥å…‹é¢¨</button>
      <button id="testMic">æ¸¬è©¦éº¥å…‹é¢¨è¨­å‚™</button>
      <div class="volume-control">
        <label for="volumeSlider">éŸ³é‡é–¾å€¼: </label>
        <input type="range" id="volumeSlider" min="0" max="100" value="5">
        <span id="volumeValue">5</span>
      </div>
      
      <div class="volume-control">
        <label for="movingAverageSlider">å¹³æ»‘å¹€æ•¸: </label>
        <input type="range" id="movingAverageSlider" min="1" max="30" value="10">
        <span id="movingAverageValue">10</span>
        <span style="color: rgba(255, 255, 255, 0.7); font-size: 12px; margin-left: 5px;">(å¹€)</span>
      </div>
      
      <!-- æ–°å¢ï¼šèƒŒæ™¯è¨­å®šä»‹é¢ -->
      <div class="training-section">
        <h3 style="color: white; margin: 20px 0 10px 0;">ğŸ¨ VTuber èƒŒæ™¯è¨­å®š</h3>
        <div class="bg-controls">
          <div class="bg-control-row">
            <label for="bgColorPicker" style="color: white; margin-right: 10px;">èƒŒæ™¯é¡è‰²ï¼š</label>
            <input type="color" id="bgColorPicker" value="#000000" style="width: 50px; height: 35px; border: none; border-radius: 5px; cursor: pointer;">
            <button id="resetBgColor" style="margin-left: 10px; padding: 8px 15px; font-size: 14px;">é‡ç½®</button>
          </div>
          
          <div class="bg-control-row">
            <label style="color: white; margin-right: 10px;">èƒŒæ™¯æ¨£å¼ï¼š</label>
            <div class="bg-style-buttons">
              <button class="bg-style-btn active" data-style="solid">ç´”è‰²</button>
              <button class="bg-style-btn" data-style="gradient">æ¼¸å±¤</button>
              <button class="bg-style-btn" data-style="transparent">é€æ˜</button>
            </div>
          </div>
          
          <div class="bg-control-row" id="gradientControls" style="display: none;">
            <label for="bgGradientColor" style="color: white; margin-right: 10px;">æ¼¸å±¤é¡è‰²ï¼š</label>
            <input type="color" id="bgGradientColor" value="#333333" style="width: 50px; height: 35px; border: none; border-radius: 5px; cursor: pointer;">
          </div>
          
          <div class="bg-control-row">
            <label for="bgOpacitySlider" style="color: white; margin-right: 10px;">ä¸é€æ˜åº¦ï¼š</label>
            <input type="range" id="bgOpacitySlider" min="0" max="100" value="100" style="width: 120px;">
            <span id="bgOpacityValue" style="color: white; margin-left: 10px; font-weight: bold;">100%</span>
          </div>
        </div>
      </div>

      <!-- æ–°å¢ï¼šå³æ™‚è¨“ç·´ä»‹é¢ -->
      <div class="training-section">
        <h3 style="color: white; margin: 20px 0 10px 0;">ğŸ¯ å³æ™‚è¨“ç·´æ¨¡å¼</h3>
        <div class="training-controls">
          <button id="toggleTraining">é–‹å§‹è¨“ç·´æ¨¡å¼</button>
          <button id="clearTrainingData">æ¸…é™¤è¨“ç·´è³‡æ–™</button>
          <button id="saveTrainingData">å„²å­˜è¨“ç·´è³‡æ–™</button>
          <button id="loadTrainingData">è¼‰å…¥è¨“ç·´è³‡æ–™</button>
          <span id="trainingStatus" style="color: #4ecdc4; margin-left: 10px;">å¾…æ©Ÿä¸­</span>
        </div>
        
        <div id="trainingInterface" style="display: none; margin-top: 15px;">
          <p style="color: white; margin: 10px 0;">æŒ‰ä½æŒ‰éˆ•ä¸¦ç™¼å‡ºå°æ‡‰è²éŸ³ï¼Œæ”¾é–‹æŒ‰éˆ•å®ŒæˆéŒ„éŸ³ï¼š</p>
          <div class="mouth-buttons">
            <button class="mouth-btn" data-mouth="a">A (å•Š)</button>
            <button class="mouth-btn" data-mouth="e">E (æ¬¸)</button>
            <button class="mouth-btn" data-mouth="i">I (å’¿)</button>
            <button class="mouth-btn" data-mouth="o">O (å–”)</button>
            <button class="mouth-btn" data-mouth="u">U (å—š)</button>
            <button class="mouth-btn" data-mouth="close">é–‰å˜´</button>
          </div>
          <div style="color: white; margin-top: 10px; font-size: 14px;">
            å·²è¨“ç·´æ¨£æœ¬ï¼š<span id="trainingCount">0</span>
          </div>
        </div>
      </div>
    </div>
  </div>
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const analyser = audioCtx.createAnalyser();
    const vtuberImage = document.getElementById('vtuberImage');
    const status = document.getElementById('status');
    const volumeSlider = document.getElementById('volumeSlider');
    const volumeValue = document.getElementById('volumeValue');
    const startMicBtn = document.getElementById('startMic');
    const stopMicBtn = document.getElementById('stopMic');
    const testMicBtn = document.getElementById('testMic');
    
    // éŸ³é‡æª¢æ¸¬ç›¸é—œè®Šæ•¸
    let volumeThreshold = 5; // éŸ³é‡é–¾å€¼ï¼Œå¯ä»¥èª¿æ•´
    let isRecording = false;
    let mediaStream = null;
    let source = null;
    let animationId = null;
    let keepAliveInterval = null; // ä¿æŒæ´»èºçš„å®šæ™‚å™¨
    let currentMouthShape = 'close'; // ç•¶å‰å˜´å‹
    let targetMouthShape = 'close'; // ç›®æ¨™å˜´å‹
    let lastMouthChangeTime = 0; // ä¸Šæ¬¡æ›å˜´å‹çš„æ™‚é–“
    let mouthShapes = ['a', 'e', 'i', 'o', 'u']; // å¯ç”¨çš„å˜´å‹
    let mouthShapeHistory = []; // å˜´å‹æ­·å²ï¼Œç”¨æ–¼å¹³æ»‘éæ¸¡
    let isTransitioning = false; // æ˜¯å¦æ­£åœ¨éæ¸¡ä¸­
    
    // Moving Average ç›¸é—œè®Šæ•¸
    let movingAverageFrames = 10; // å¹³å‡ frame æ•¸é‡ï¼ˆå¯èª¿æ•´ï¼‰
    let volumeHistory = []; // éŸ³é‡æ­·å²ç·©è¡å€
    let frequencyHistory = []; // é »ç‡è³‡æ–™æ­·å²ç·©è¡å€
    
    // çœ¨çœ¼ç›¸é—œè®Šæ•¸
    let lastBlinkTime = 0; // ä¸Šæ¬¡çœ¨çœ¼æ™‚é–“
    let isBlinking = false; // æ˜¯å¦æ­£åœ¨çœ¨çœ¼
    let blinkStartTime = 0; // çœ¨çœ¼é–‹å§‹æ™‚é–“
    let lastSoundTime = 0; // ä¸Šæ¬¡æœ‰è²éŸ³çš„æ™‚é–“
    let lastBlinkCheckTime = 0; // ä¸Šæ¬¡æª¢æŸ¥çœ¨çœ¼çš„æ™‚é–“
    let nextBlinkCheckInterval = 1000; // ä¸‹æ¬¡æª¢æŸ¥çœ¨çœ¼çš„é–“éš”æ™‚é–“
    const BLINK_DURATION = 100; // çœ¨çœ¼æŒçºŒæ™‚é–“ (æ¯«ç§’)
    const BLINK_CHECK_MIN = 1000; // çœ¨çœ¼æª¢æŸ¥æœ€å°é–“éš” (æ¯«ç§’)
    const BLINK_CHECK_MAX = 2000; // çœ¨çœ¼æª¢æŸ¥æœ€å¤§é–“éš” (æ¯«ç§’)
    const BLINK_PROBABILITY = 0.3; // çœ¨çœ¼æ©Ÿç‡ (30%)
    
    // è¨“ç·´ç³»çµ±è®Šæ•¸
    let isTrainingMode = false;
    let trainingData = []; // å„²å­˜è¨“ç·´è³‡æ–™ {features: [], label: ''}
    let currentAudioFeatures = null; // ç•¶å‰éŸ³è¨Šç‰¹å¾µ
    let isRecordingForTraining = false;
    
    // æŒ‰ä½éŒ„éŸ³ç›¸é—œè®Šæ•¸
    let recordingBuffer = []; // éŒ„éŸ³ç·©è¡å€
    let recordingStartTime = 0;
    let currentRecordingButton = null;
    let recordingTimer = null;
    
    // Moving Average è¨ˆç®—å‡½æ•¸
    function addToMovingAverage(history, newValue, maxLength) {
      history.push(newValue);
      if (history.length > maxLength) {
        history.shift(); // ç§»é™¤æœ€èˆŠçš„è³‡æ–™
      }
      return history;
    }
    
    // è¨ˆç®—æ•¸å€¼é™£åˆ—çš„å¹³å‡å€¼
    function calculateAverage(values) {
      if (values.length === 0) return 0;
      const sum = values.reduce((acc, val) => acc + val, 0);
      return sum / values.length;
    }
    
    // è¨ˆç®—é »ç‡é™£åˆ—çš„å¹³å‡å€¼ï¼ˆæ¯å€‹é »ç‡ bin åˆ†åˆ¥è¨ˆç®—ï¼‰
    function calculateFrequencyAverage(frequencyHistoryArray) {
      if (frequencyHistoryArray.length === 0) return null;
      
      const binCount = frequencyHistoryArray[0].length;
      const averagedFrequency = new Uint8Array(binCount);
      
      for (let bin = 0; bin < binCount; bin++) {
        let sum = 0;
        for (let frame = 0; frame < frequencyHistoryArray.length; frame++) {
          sum += frequencyHistoryArray[frame][bin];
        }
        averagedFrequency[bin] = Math.round(sum / frequencyHistoryArray.length);
      }
      
      return averagedFrequency;
    }

    // æ»‘æ¡¿æ§åˆ¶äº‹ä»¶
    volumeSlider.addEventListener('input', function(e) {
      volumeThreshold = parseInt(e.target.value);
      volumeValue.textContent = volumeThreshold;
    });
    
    // Moving Average æ»‘æ¡¿æ§åˆ¶äº‹ä»¶
    const movingAverageSlider = document.getElementById('movingAverageSlider');
    const movingAverageValue = document.getElementById('movingAverageValue');
    
    movingAverageSlider.addEventListener('input', function(e) {
      const newFrameCount = parseInt(e.target.value);
      movingAverageValue.textContent = newFrameCount;
      
      // æ›´æ–° frame æ•¸é‡
      movingAverageFrames = newFrameCount;
      
      // æ¸…é™¤ç¾æœ‰çš„æ­·å²ç·©è¡å€ï¼Œé¿å…ä¸ä¸€è‡´çš„ç‹€æ…‹
      volumeHistory = [];
      frequencyHistory = [];
      
      console.log(`Moving Average å¹€æ•¸å·²èª¿æ•´ç‚º: ${movingAverageFrames}`);
    });
    
    // é è¼‰å…¥åœ–ç‰‡
    const mouthCloseImg = new Image();
    const mouthOpenA = new Image();
    const mouthOpenE = new Image();
    const mouthOpenI = new Image();
    const mouthOpenO = new Image();
    const mouthOpenU = new Image();
    const mouthBlinkImg = new Image(); // çœ¨çœ¼åœ–ç‰‡
    
    mouthCloseImg.src = 'assets/vtuber-mouth-close.png';
    mouthOpenA.src = 'assets/vtuber-mouth-open-a.png';
    mouthOpenE.src = 'assets/vtuber-mouth-open-e.png';
    mouthOpenI.src = 'assets/vtuber-mouth-open-i.png';
    mouthOpenO.src = 'assets/vtuber-mouth-open-o.png';
    mouthOpenU.src = 'assets/vtuber-mouth-open-u.png';
    mouthBlinkImg.src = 'assets/vtuber-mouth-close-blink.png';
    
    // éš¨æ©Ÿé¸æ“‡å˜´å‹çš„å‡½æ•¸
    function getRandomMouthShape() {
      const randomIndex = Math.floor(Math.random() * mouthShapes.length);
      return mouthShapes[randomIndex];
    }
    
    // æ ¹æ“šéŸ³é‡å’Œé »ç‡ç‰¹å¾µæ±ºå®šå˜´å‹çš„å‡½æ•¸ï¼ˆæ™ºèƒ½ç‰ˆï¼‰
    function decideMouthShape(volume, frequencyData) {
      const currentTime = Date.now();
      
      if (volume <= volumeThreshold) {
        targetMouthShape = 'close';
        // å¹³æ»‘éæ¸¡åˆ°é–‰å˜´ç‹€æ…‹
        if (currentMouthShape !== 'close') {
          smoothTransitionTo('close');
        }
        return currentMouthShape;
      }
      
      // æå–ç•¶å‰éŸ³è¨Šç‰¹å¾µ
      currentAudioFeatures = normalizeFeatures(extractAudioFeatures(frequencyData, volume));
      
      // æ ¹æ“šæ˜¯å¦æœ‰è¨“ç·´è³‡æ–™ä¾†æ±ºå®šå˜´å‹
      const suggestedMouthShape = trainingData.length >= 5 
        ? predictMouthShapeFromTraining(currentAudioFeatures)
        : analyzeFrequencyForMouthShape(frequencyData);
      
      // æ·»åŠ åˆ°æ­·å²è¨˜éŒ„
      mouthShapeHistory.push(suggestedMouthShape);
      if (mouthShapeHistory.length > 5) {
        mouthShapeHistory.shift(); // ä¿æŒæœ€è¿‘5æ¬¡çš„è¨˜éŒ„
      }
      
      // æ ¹æ“šæ­·å²è¨˜éŒ„æ±ºå®šæœ€çµ‚å˜´å‹ï¼ˆé¿å…éæ–¼é »ç¹çš„è®ŠåŒ–ï¼‰
      const mostFrequentShape = getMostFrequentShape(mouthShapeHistory);
      
      // ç•¶æœ‰è²éŸ³æ™‚ï¼Œæ ¹æ“šé »ç‡ç‰¹å¾µå’Œæ­·å²æ±ºå®šå˜´å‹
      const timeSinceLastChange = currentTime - lastMouthChangeTime;
      const minChangeInterval = 120; // æœ€å°è®ŠåŒ–é–“éš”
      
      if (timeSinceLastChange > minChangeInterval && 
          (mostFrequentShape !== currentMouthShape || currentMouthShape === 'close')) {
        targetMouthShape = mostFrequentShape;
        smoothTransitionTo(targetMouthShape);
        lastMouthChangeTime = currentTime;
      }
      
      return currentMouthShape;
    }
    
    // å¹³æ»‘éæ¸¡åˆ°ç›®æ¨™å˜´å‹
    function smoothTransitionTo(targetShape) {
      if (isTransitioning || currentMouthShape === targetShape) return;
      
      isTransitioning = true;
      const startTime = Date.now();
      const transitionDuration = 150; // 150ms éæ¸¡æ™‚é–“
      
      function transition() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / transitionDuration, 1);
        
        if (progress >= 1) {
          currentMouthShape = targetShape;
          isTransitioning = false;
          return;
        }
        
        // åœ¨éæ¸¡éç¨‹ä¸­å¯ä»¥æ·»åŠ ä¸­é–“ç‹€æ…‹
        requestAnimationFrame(transition);
      }
      
      currentMouthShape = targetShape;
      requestAnimationFrame(transition);
    }
    
    // ç²å–æ­·å²è¨˜éŒ„ä¸­æœ€é »ç¹çš„å˜´å‹
    function getMostFrequentShape(history) {
      if (history.length === 0) return 'a';
      
      const frequency = {};
      history.forEach(shape => {
        frequency[shape] = (frequency[shape] || 0) + 1;
      });
      
      return Object.keys(frequency).reduce((a, b) => 
        frequency[a] > frequency[b] ? a : b
      );
    }
    
    // æ–°å¢ï¼šåŸºæ–¼é »ç‡åˆ†æçš„å˜´å‹è­˜åˆ¥
    function analyzeFrequencyForMouthShape(frequencyData) {
      // è¨ˆç®—ä¸åŒé »ç‡ç¯„åœçš„èƒ½é‡
      const lowFreq = getFrequencyEnergy(frequencyData, 0, 300);    // ä½é » (a, o, u)
      const midFreq = getFrequencyEnergy(frequencyData, 300, 2000); // ä¸­é » (e, o)
      const highFreq = getFrequencyEnergy(frequencyData, 2000, 8000); // é«˜é » (i, e)
      
      // æ ¹æ“šé »ç‡ç‰¹å¾µæ±ºå®šå˜´å‹
      const totalEnergy = lowFreq + midFreq + highFreq;
      if (totalEnergy < 10) return getRandomMouthShape(); // èƒ½é‡å¤ªä½æ™‚ä½¿ç”¨éš¨æ©Ÿ
      
      const lowRatio = lowFreq / totalEnergy;
      const midRatio = midFreq / totalEnergy;
      const highRatio = highFreq / totalEnergy;
      
      // åŸºæ–¼é »ç‡æ¯”ä¾‹æ±ºå®šå˜´å‹
      if (lowRatio > 0.4 && highRatio < 0.3) {
        return Math.random() > 0.5 ? 'a' : 'o'; // ä½é »ä¸»å°ï¼ša æˆ– o
      } else if (highRatio > 0.4) {
        return Math.random() > 0.5 ? 'i' : 'e'; // é«˜é »ä¸»å°ï¼ši æˆ– e
      } else if (midRatio > 0.4) {
        return Math.random() > 0.6 ? 'e' : (Math.random() > 0.5 ? 'o' : 'u'); // ä¸­é »ä¸»å°ï¼še, o, u
      } else {
        return 'u'; // å¹³è¡¡ç‹€æ…‹ï¼šu
      }
    }
    
    // è¨ˆç®—ç‰¹å®šé »ç‡ç¯„åœçš„èƒ½é‡
    function getFrequencyEnergy(frequencyData, minFreq, maxFreq) {
      const sampleRate = audioCtx.sampleRate;
      const fftSize = analyser.fftSize;
      const frequencyBinCount = analyser.frequencyBinCount;
      
      const minBin = Math.floor(minFreq * fftSize / sampleRate);
      const maxBin = Math.floor(maxFreq * fftSize / sampleRate);
      
      let energy = 0;
      for (let i = minBin; i < Math.min(maxBin, frequencyBinCount); i++) {
        energy += frequencyData[i] * frequencyData[i];
      }
      
      return Math.sqrt(energy / (maxBin - minBin));
    }
    
    // æå–éŸ³è¨Šç‰¹å¾µå‘é‡ï¼ˆç”¨æ–¼è¨“ç·´ï¼‰
    function extractAudioFeatures(frequencyData, volume) {
      const features = [];
      
      // åŸºæœ¬éŸ³é‡ç‰¹å¾µ
      features.push(volume);
      
      // é »ç‡èƒ½é‡ç‰¹å¾µï¼ˆæ›´è©³ç´°çš„åˆ†å‰²ï¼‰
      const frequencyRanges = [
        [0, 200],     // è¶…ä½é »
        [200, 400],   // ä½é »1
        [400, 800],   // ä½é »2
        [800, 1600],  // ä¸­ä½é »
        [1600, 3200], // ä¸­é »
        [3200, 6400], // ä¸­é«˜é »
        [6400, 12800] // é«˜é »
      ];
      
      frequencyRanges.forEach(([min, max]) => {
        features.push(getFrequencyEnergy(frequencyData, min, max));
      });
      
      // é »è­œé‡å¿ƒ (Spectral Centroid)
      let weightedSum = 0;
      let magnitudeSum = 0;
      for (let i = 0; i < frequencyData.length; i++) {
        const frequency = i * audioCtx.sampleRate / analyser.fftSize;
        weightedSum += frequency * frequencyData[i];
        magnitudeSum += frequencyData[i];
      }
      const spectralCentroid = magnitudeSum > 0 ? weightedSum / magnitudeSum : 0;
      features.push(spectralCentroid);
      
      // é »è­œæ»¾é™é» (Spectral Rolloff)
      const totalEnergy = frequencyData.reduce((sum, val) => sum + val, 0);
      let runningSum = 0;
      let rolloffIndex = 0;
      for (let i = 0; i < frequencyData.length; i++) {
        runningSum += frequencyData[i];
        if (runningSum >= totalEnergy * 0.85) {
          rolloffIndex = i;
          break;
        }
      }
      const rolloffFreq = rolloffIndex * audioCtx.sampleRate / analyser.fftSize;
      features.push(rolloffFreq);
      
      return features;
    }
    
    // ä½¿ç”¨è¨“ç·´è³‡æ–™é æ¸¬å˜´å‹ï¼ˆç°¡å–®çš„ k-NN åˆ†é¡å™¨ï¼‰
    function predictMouthShapeFromTraining(features) {
      if (trainingData.length < 5) {
        return analyzeFrequencyForMouthShape(features); // å›é€€åˆ°åŸå§‹æ–¹æ³•
      }
      
      // è¨ˆç®—èˆ‡æ‰€æœ‰è¨“ç·´æ¨£æœ¬çš„è·é›¢
      const distances = trainingData.map(sample => {
        const distance = euclideanDistance(features, sample.features);
        return { distance, label: sample.label };
      });
      
      // æŒ‰è·é›¢æ’åºï¼Œå–æœ€è¿‘çš„ k å€‹æ¨£æœ¬
      const k = Math.min(5, trainingData.length);
      distances.sort((a, b) => a.distance - b.distance);
      const nearestNeighbors = distances.slice(0, k);
      
      // æŠ•ç¥¨æ±ºå®šæœ€çµ‚æ¨™ç±¤
      const votes = {};
      nearestNeighbors.forEach(neighbor => {
        votes[neighbor.label] = (votes[neighbor.label] || 0) + 1;
      });
      
      // è¿”å›å¾—ç¥¨æœ€å¤šçš„æ¨™ç±¤
      return Object.keys(votes).reduce((a, b) => votes[a] > votes[b] ? a : b);
    }
    
    // è¨ˆç®—æ­å¹¾é‡Œå¾—è·é›¢
    function euclideanDistance(features1, features2) {
      if (features1.length !== features2.length) return Infinity;
      
      let sum = 0;
      for (let i = 0; i < features1.length; i++) {
        const diff = features1[i] - features2[i];
        sum += diff * diff;
      }
      return Math.sqrt(sum);
    }
    
    // æ­£è¦åŒ–ç‰¹å¾µå‘é‡
    function normalizeFeatures(features) {
      const max = Math.max(...features);
      const min = Math.min(...features);
      const range = max - min;
      
      if (range === 0) return features;
      
      return features.map(f => (f - min) / range);
    }
    
    // ç”Ÿæˆéš¨æ©Ÿçš„çœ¨çœ¼æª¢æŸ¥é–“éš”æ™‚é–“
    function generateNextBlinkCheckInterval() {
      return Math.random() * (BLINK_CHECK_MAX - BLINK_CHECK_MIN) + BLINK_CHECK_MIN;
    }
    
    // çœ¨çœ¼é‚è¼¯å‡½æ•¸
    function checkAndTriggerBlink(currentTime, volume) {
      // å¦‚æœæ­£åœ¨çœ¨çœ¼ï¼Œæª¢æŸ¥æ˜¯å¦è©²çµæŸ
      if (isBlinking) {
        if (currentTime - blinkStartTime >= BLINK_DURATION) {
          isBlinking = false;
          console.log('çœ¨çœ¼çµæŸ');
        }
        return true; // ä»åœ¨çœ¨çœ¼ä¸­
      }
      
      // è¨˜éŒ„æœ‰è²éŸ³çš„æ™‚é–“ï¼Œä¸¦é‡ç½®æª¢æŸ¥è¨ˆæ™‚å™¨
      if (volume > volumeThreshold) {
        lastSoundTime = currentTime;
        lastBlinkCheckTime = currentTime; // é‡ç½®æª¢æŸ¥æ™‚é–“
        nextBlinkCheckInterval = generateNextBlinkCheckInterval(); // ç”Ÿæˆæ–°çš„æª¢æŸ¥é–“éš”
        return false; // æœ‰è²éŸ³æ™‚ä¸çœ¨çœ¼
      }
      
      // æª¢æŸ¥æ˜¯å¦åˆ°äº†è©²æª¢æŸ¥çœ¨çœ¼çš„æ™‚é–“
      const timeSinceLastCheck = currentTime - lastBlinkCheckTime;
      if (timeSinceLastCheck < nextBlinkCheckInterval) {
        return false; // é‚„æ²’åˆ°æª¢æŸ¥æ™‚é–“
      }
      
      // åˆ°äº†æª¢æŸ¥æ™‚é–“ï¼Œæ›´æ–°æª¢æŸ¥æ™‚é–“ä¸¦ç”Ÿæˆä¸‹æ¬¡æª¢æŸ¥é–“éš”
      lastBlinkCheckTime = currentTime;
      nextBlinkCheckInterval = generateNextBlinkCheckInterval();
      
      // æª¢æŸ¥æ˜¯å¦åœ¨å®‰éœç‹€æ…‹ï¼ˆè‡³å°‘å®‰éœ500msæ‰è€ƒæ…®çœ¨çœ¼ï¼‰
      const quietDuration = currentTime - lastSoundTime;
      if (quietDuration < 500) {
        console.log(`å®‰éœæ™‚é–“ä¸å¤ : ${quietDuration}msï¼Œä¸‹æ¬¡æª¢æŸ¥é–“éš”: ${nextBlinkCheckInterval}ms`);
        return false;
      }
      
      // 30%æ©Ÿç‡è§¸ç™¼çœ¨çœ¼
      if (Math.random() < BLINK_PROBABILITY) {
        isBlinking = true;
        blinkStartTime = currentTime;
        lastBlinkTime = currentTime;
        console.log(`è§¸ç™¼çœ¨çœ¼ï¼å®‰éœæ™‚é–“: ${quietDuration}msï¼Œä¸‹æ¬¡æª¢æŸ¥é–“éš”: ${nextBlinkCheckInterval}ms`);
        return true;
      } else {
        console.log(`æœªè§¸ç™¼çœ¨çœ¼ï¼Œå®‰éœæ™‚é–“: ${quietDuration}msï¼Œä¸‹æ¬¡æª¢æŸ¥é–“éš”: ${nextBlinkCheckInterval}ms`);
      }
      
      return false;
    }
    
    // æ›´æ–° VTuber å˜´å‹çš„å‡½æ•¸ï¼ˆåŠ å…¥çœ¨çœ¼æ”¯æŒï¼‰
    function updateMouthShape(vowel, volume) {
      const currentTime = Date.now();
      
      // æª¢æŸ¥æ˜¯å¦éœ€è¦çœ¨çœ¼
      const shouldBlink = checkAndTriggerBlink(currentTime, volume);
      
      let imageSrc = 'assets/vtuber-mouth-close.png';
      let transform = 'scaleX(-1)';
      
      // å¦‚æœæ­£åœ¨çœ¨çœ¼ï¼Œä½¿ç”¨çœ¨çœ¼åœ–ç‰‡
      if (shouldBlink) {
        imageSrc = 'assets/vtuber-mouth-close-blink.png';
        transform = 'scaleX(-1)';
      } else if (volume > volumeThreshold) {
        // æœ‰è²éŸ³æ™‚æ ¹æ“šå˜´å‹é¸æ“‡åœ–ç‰‡
        switch (vowel) {
          case 'a':
            imageSrc = 'assets/vtuber-mouth-open-a.png';
            transform = 'scaleX(-1) scale(1.05)';
            break;
          case 'e':
            imageSrc = 'assets/vtuber-mouth-open-e.png';
            transform = 'scaleX(-1) scale(1.03)';
            break;
          case 'i':
            imageSrc = 'assets/vtuber-mouth-open-i.png';
            transform = 'scaleX(-1) scale(1.02)';
            break;
          case 'o':
            imageSrc = 'assets/vtuber-mouth-open-o.png';
            transform = 'scaleX(-1) scale(1.04)';
            break;
          case 'u':
            imageSrc = 'assets/vtuber-mouth-open-u.png';
            transform = 'scaleX(-1) scale(1.03)';
            break;
          default:
            imageSrc = 'assets/vtuber-mouth-open.png';
            transform = 'scaleX(-1) scale(1.05)';
            break;
        }
      }
      // å®‰éœæ™‚ä¿æŒé–‰å˜´ç‹€æ…‹ï¼ˆå·²è¨­å®šç‚ºé è¨­å€¼ï¼‰
      
      vtuberImage.src = imageSrc;
      vtuberImage.style.transform = transform;
    }
    
    // è‡ªå‹•å•Ÿå‹•éº¥å…‹é¢¨çš„å‡½æ•¸
    async function autoStartMicrophone() {
      // éš±è—é»æ“Šæç¤ºï¼Œé¡¯ç¤ºæ§åˆ¶é …
      document.getElementById('clickToStart').style.display = 'none';
      document.getElementById('canvas').style.display = 'block';
      document.querySelector('.controls').style.display = 'flex';
      
      // æ¨¡æ“¬é»æ“Šé–‹å§‹éº¥å…‹é¢¨æŒ‰éˆ•
      startMicBtn.click();
    }

    // é–‹å§‹ä½¿ç”¨éº¥å…‹é¢¨
    startMicBtn.addEventListener('click', async function() {
      try {
        status.textContent = 'æ­£åœ¨è«‹æ±‚éº¥å…‹é¢¨æ¬Šé™...';
        
        // æª¢æŸ¥ç€è¦½å™¨æ˜¯å¦æ”¯æ´getUserMedia
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          throw new Error('æ‚¨çš„ç€è¦½å™¨ä¸æ”¯æ´éº¥å…‹é¢¨åŠŸèƒ½');
        }
        
        // éœ€è¦ä½¿ç”¨è€…äº’å‹•ä¾†å•Ÿå‹•AudioContext
        if (audioCtx.state === 'suspended') {
          await audioCtx.resume();
        }
        
        // è«‹æ±‚éº¥å…‹é¢¨æ¬Šé™ - ä½¿ç”¨ç¨å æ¨¡å¼é¿å…è¡çª
        mediaStream = await navigator.mediaDevices.getUserMedia({ 
          audio: {
            echoCancellation: false,
            noiseSuppression: false,
            autoGainControl: false,
            sampleRate: 44100,
            channelCount: 1,
            latency: 0.01
          } 
        });
        
        console.log('éº¥å…‹é¢¨ä¸²æµå·²å»ºç«‹:', mediaStream);
        
        // å»ºç«‹éŸ³è¨Šä¾†æº
        source = audioCtx.createMediaStreamSource(mediaStream);
        source.connect(analyser);
        
        console.log('éŸ³è¨Šä¾†æºå·²é€£æ¥åˆ°åˆ†æå™¨');
        
        isRecording = true;
        status.textContent = 'ğŸ¤ éº¥å…‹é¢¨å·²é–‹å•Ÿï¼Œé–‹å§‹ç›£è½... (è«‹èªªè©±æ¸¬è©¦)';
        
                 // åˆå§‹åŒ–çœ¨çœ¼ç›¸é—œè®Šæ•¸
         const currentTime = Date.now();
         lastSoundTime = currentTime;
         lastBlinkTime = 0;
         isBlinking = false;
         lastBlinkCheckTime = currentTime;
         nextBlinkCheckInterval = generateNextBlinkCheckInterval();
         
         // æ¸…é™¤ moving average ç·©è¡å€
         volumeHistory = [];
         frequencyHistory = [];
        
        // æ›´æ–°æŒ‰éˆ•ç‹€æ…‹
        startMicBtn.disabled = true;
        stopMicBtn.disabled = false;
        
        // è¨­å®šåˆ†æå™¨
        analyser.fftSize = 2048;
        const bufferLength = analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        const frequencyData = new Uint8Array(bufferLength);
        
        let noAudioCount = 0;
        let lastVolumeTime = Date.now();
        
        function draw() {
          if (!isRecording) return;
          
          // ç¢ºä¿éŸ³è¨Šä¸Šä¸‹æ–‡å§‹çµ‚è™•æ–¼é‹è¡Œç‹€æ…‹
          if (audioCtx.state === 'suspended') {
            console.log('éŸ³è¨Šä¸Šä¸‹æ–‡æš«åœï¼Œæ­£åœ¨æ¢å¾©...');
            audioCtx.resume().then(() => {
              console.log('éŸ³è¨Šä¸Šä¸‹æ–‡å·²æ¢å¾©');
            }).catch(err => {
              console.error('ç„¡æ³•æ¢å¾©éŸ³è¨Šä¸Šä¸‹æ–‡:', err);
            });
          }
          
          // æª¢æŸ¥éŸ³è¨Šä¸²æµæ˜¯å¦ä»ç„¶æ´»èº
          if (mediaStream && mediaStream.getTracks().length > 0) {
            const track = mediaStream.getTracks()[0];
            if (track.readyState === 'ended') {
              console.warn('éŸ³è¨Šè»Œé“å·²çµæŸï¼Œå˜—è©¦é‡æ–°é€£æ¥...');
              status.textContent = 'ğŸ”„ éº¥å…‹é¢¨é€£ç·šä¸­æ–·ï¼Œæ­£åœ¨é‡æ–°é€£æ¥...';
              // ç«‹å³å˜—è©¦é‡æ–°å•Ÿå‹•éº¥å…‹é¢¨
              setTimeout(() => {
                if (isRecording) {
                  stopMicrophone();
                  setTimeout(() => startMicBtn.click(), 500);
                }
              }, 100);
              return;
            }
          }
          
          animationId = requestAnimationFrame(draw);
          analyser.getByteTimeDomainData(dataArray);
          analyser.getByteFrequencyData(frequencyData);
          
          // è¨ˆç®—éŸ³é‡ï¼ˆRMSï¼‰- ä½¿ç”¨æ›´æ•æ„Ÿçš„ç®—æ³•
          let sum = 0;
          let maxAmplitude = 0;
          for (let i = 0; i < bufferLength; i++) {
            const amplitude = Math.abs((dataArray[i] - 128) / 128);
            sum += amplitude * amplitude;
            maxAmplitude = Math.max(maxAmplitude, amplitude);
          }
          const rmsVolume = Math.sqrt(sum / bufferLength) * 100;
          const peakVolume = maxAmplitude * 100;
          
          // ä½¿ç”¨å³°å€¼å’ŒRMSçš„çµ„åˆä¾†ç²å¾—æ›´å¥½çš„éŸ¿æ‡‰
          const instantVolume = Math.max(rmsVolume, peakVolume * 0.3);
          
          // æ·»åŠ åˆ° moving average ç·©è¡å€
          addToMovingAverage(volumeHistory, instantVolume, movingAverageFrames);
          addToMovingAverage(frequencyHistory, Array.from(frequencyData), movingAverageFrames);
          
          // è¨ˆç®—å¹³æ»‘å¾Œçš„éŸ³é‡å’Œé »ç‡è³‡æ–™
          const volume = calculateAverage(volumeHistory);
          const smoothedFrequencyData = calculateFrequencyAverage(frequencyHistory) || frequencyData;
          
          // ç°¡åŒ–çš„èª¿è©¦è³‡è¨Š
          if (Math.random() < 0.02) { // æ¯50å¹€è¼¸å‡ºä¸€æ¬¡èª¿è©¦è³‡è¨Š
            console.log('ğŸ¤ éŸ³é‡:', volume.toFixed(1), 'é–¾å€¼:', volumeThreshold, 'ç•¶å‰å˜´å‹:', currentMouthShape);
          }
          
          // æ±ºå®šå˜´å‹ä¸¦æ›´æ–°ï¼ˆä½¿ç”¨å¹³æ»‘åŒ–å¾Œçš„è³‡æ–™ï¼‰
          const mouthShape = decideMouthShape(volume, smoothedFrequencyData);
          updateMouthShape(mouthShape, volume);
          
          // æ›´æ–°ç‹€æ…‹é¡¯ç¤º
          const mouthDisplay = mouthShape === 'close' ? 'é–‰å˜´' : `å˜´å‹: ${mouthShape.toUpperCase()}`;
          status.textContent = `ğŸ¤ å³æ™‚éŸ³é‡: ${instantVolume.toFixed(1)} | å¹³æ»‘éŸ³é‡: ${volume.toFixed(1)} (${movingAverageFrames}å¹€) | ${mouthDisplay} ${volume > volumeThreshold ? '(èªªè©±ä¸­)' : '(å®‰éœ)'}`;

          // ç¹ªè£½æ³¢å½¢åœ–
          ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // ç¹ªè£½æ™‚åŸŸæ³¢å½¢
          ctx.lineWidth = 2;
          ctx.strokeStyle = volume > volumeThreshold ? '#ff6b6b' : '#4ecdc4';
          ctx.beginPath();

          let sliceWidth = canvas.width * 1.0 / bufferLength;
          let x = 0;

          for (let i = 0; i < bufferLength; i++) {
            let v = dataArray[i] / 128.0;
            let y = v * canvas.height / 2;

            if (i === 0) {
              ctx.moveTo(x, y);
            } else {
              ctx.lineTo(x, y);
            }

            x += sliceWidth;
          }

          ctx.lineTo(canvas.width, canvas.height / 2);
          ctx.stroke();
          
          // ç¹ªè£½é »è­œåˆ†æ
          ctx.fillStyle = volume > volumeThreshold ? 'rgba(255, 107, 107, 0.6)' : 'rgba(78, 205, 196, 0.6)';
          const barWidth = canvas.width / bufferLength * 2;
          let barHeight;
          x = 0;

          for (let i = 0; i < bufferLength / 2; i++) {
            barHeight = (frequencyData[i] / 255) * canvas.height * 0.3;
            ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
            x += barWidth + 1;
          }
        }
        
        draw();
        
        // å•Ÿå‹•ä¿æŒæ´»èºçš„å®šæ™‚å™¨ï¼Œç¢ºä¿å³ä½¿åœ¨èƒŒæ™¯æ¨¡å¼ä¸‹ä¹Ÿèƒ½æŒçºŒé‹ä½œ
        keepAliveInterval = setInterval(() => {
          if (isRecording && audioCtx.state === 'suspended') {
            console.log('å®šæ™‚å™¨æª¢æŸ¥ï¼šéŸ³è¨Šä¸Šä¸‹æ–‡æš«åœï¼Œæ­£åœ¨æ¢å¾©...');
            audioCtx.resume().catch(err => {
              console.error('å®šæ™‚å™¨æ¢å¾©éŸ³è¨Šä¸Šä¸‹æ–‡å¤±æ•—:', err);
            });
          }
          // å¼·åˆ¶è§¸ç™¼ä¸€æ¬¡éŸ³è¨Šè™•ç†ä»¥ä¿æŒæ´»èº
          if (isRecording && analyser) {
            const tempData = new Uint8Array(analyser.frequencyBinCount);
            analyser.getByteTimeDomainData(tempData);
          }
        }, 1000); // æ¯ç§’æª¢æŸ¥ä¸€æ¬¡
        
      } catch (error) {
        console.error('ç„¡æ³•å­˜å–éº¥å…‹é¢¨:', error);
        let errorMessage = 'âŒ ç„¡æ³•å­˜å–éº¥å…‹é¢¨ï¼š';
        
        if (error.name === 'NotAllowedError') {
          errorMessage += 'æ¬Šé™è¢«æ‹’çµ•ï¼Œè«‹å…è¨±éº¥å…‹é¢¨æ¬Šé™';
        } else if (error.name === 'NotFoundError') {
          errorMessage += 'æ‰¾ä¸åˆ°éº¥å…‹é¢¨è¨­å‚™';
        } else if (error.name === 'NotSupportedError') {
          errorMessage += 'ç€è¦½å™¨ä¸æ”¯æ´æ­¤åŠŸèƒ½';
        } else if (error.name === 'NotReadableError') {
          errorMessage += 'éº¥å…‹é¢¨è¢«å…¶ä»–æ‡‰ç”¨ç¨‹å¼å ç”¨';
        } else {
          errorMessage += error.message || 'æœªçŸ¥éŒ¯èª¤';
        }
        
        status.textContent = errorMessage;
        
        // é‡ç½®æŒ‰éˆ•ç‹€æ…‹
        startMicBtn.disabled = false;
        stopMicBtn.disabled = true;
      }
    });
    
    // åœæ­¢éº¥å…‹é¢¨
    function stopMicrophone() {
      if (mediaStream) {
        // åœæ­¢æ‰€æœ‰éŸ³è¨Šè»Œé“
        mediaStream.getTracks().forEach(track => {
          track.stop();
          console.log('éŸ³è¨Šè»Œé“å·²åœæ­¢:', track.label);
        });
        mediaStream = null;
      }
      
      if (source) {
        source.disconnect();
        source = null;
      }
      
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
      
      if (keepAliveInterval) {
        clearInterval(keepAliveInterval);
        keepAliveInterval = null;
      }
      
      isRecording = false;
      status.textContent = 'éº¥å…‹é¢¨å·²åœæ­¢ï¼Œé»æ“Šã€Œé–‹å§‹ä½¿ç”¨éº¥å…‹é¢¨ã€é‡æ–°é–‹å§‹';
      
      // é‡ç½®å˜´å‹ç‹€æ…‹
      currentMouthShape = 'close';
      lastMouthChangeTime = 0;
      vtuberImage.src = 'assets/vtuber-mouth-close.png';
      vtuberImage.style.transform = 'scaleX(-1)';
      
      // é‡ç½®çœ¨çœ¼ç‹€æ…‹
      isBlinking = false;
      lastBlinkTime = 0;
      lastSoundTime = 0;
      lastBlinkCheckTime = 0;
      nextBlinkCheckInterval = 1000;
      
      // æ¸…é™¤ moving average ç·©è¡å€
      volumeHistory = [];
      frequencyHistory = [];
      
      // æ›´æ–°æŒ‰éˆ•ç‹€æ…‹
      startMicBtn.disabled = false;
      stopMicBtn.disabled = true;
      
      // æ¸…ç©ºç•«å¸ƒ
      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
    
    stopMicBtn.addEventListener('click', stopMicrophone);
    
    // é˜²æ­¢é é¢åœ¨å¤±å»ç„¦é»æ™‚æš«åœéŸ³è¨Šè™•ç†
    document.addEventListener('visibilitychange', function() {
      if (document.hidden) {
        console.log('é é¢éš±è—ï¼Œä½†éŸ³è¨Šè™•ç†ç¹¼çºŒé‹è¡Œ');
        // ä¸æš«åœä»»ä½•éŸ³è¨Šè™•ç†
      } else {
        console.log('é é¢é‡æ–°å¯è¦‹');
        // ç¢ºä¿éŸ³è¨Šä¸Šä¸‹æ–‡è™•æ–¼é‹è¡Œç‹€æ…‹
        if (audioCtx.state === 'suspended' && isRecording) {
          audioCtx.resume();
        }
      }
    });
    
    // é˜²æ­¢çª—å£å¤±å»ç„¦é»æ™‚æš«åœ
    window.addEventListener('blur', function() {
      console.log('çª—å£å¤±å»ç„¦é»ï¼Œä½†éŸ³è¨Šè™•ç†ç¹¼çºŒ');
      // ç¢ºä¿éŸ³è¨Šä¸Šä¸‹æ–‡ä¸æœƒæš«åœ
      if (audioCtx.state === 'suspended' && isRecording) {
        audioCtx.resume();
      }
    });
    
    window.addEventListener('focus', function() {
      console.log('çª—å£é‡æ–°ç²å¾—ç„¦é»');
      // ç¢ºä¿éŸ³è¨Šä¸Šä¸‹æ–‡è™•æ–¼é‹è¡Œç‹€æ…‹
      if (audioCtx.state === 'suspended' && isRecording) {
        audioCtx.resume();
      }
    });
    
    // æ¸¬è©¦éº¥å…‹é¢¨åŠŸèƒ½
    testMicBtn.addEventListener('click', async function() {
      try {
        status.textContent = 'æ­£åœ¨æª¢æ¸¬éº¥å…‹é¢¨è¨­å‚™...';
        
        // åˆ—å‡ºæ‰€æœ‰éŸ³è¨Šè¼¸å…¥è¨­å‚™
        const devices = await navigator.mediaDevices.enumerateDevices();
        const audioInputs = devices.filter(device => device.kind === 'audioinput');
        
        console.log('æ‰¾åˆ°çš„éŸ³è¨Šè¼¸å…¥è¨­å‚™:', audioInputs);
        
        if (audioInputs.length === 0) {
          status.textContent = 'âŒ æ‰¾ä¸åˆ°ä»»ä½•éº¥å…‹é¢¨è¨­å‚™';
          return;
        }
        
        // æ¸¬è©¦é è¨­éº¥å…‹é¢¨
        const testStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        console.log('éº¥å…‹é¢¨æ¸¬è©¦æˆåŠŸ:', testStream);
        
        // ç«‹å³åœæ­¢æ¸¬è©¦ä¸²æµ
        testStream.getTracks().forEach(track => track.stop());
        
        status.textContent = `âœ… éº¥å…‹é¢¨æ¸¬è©¦æˆåŠŸï¼æ‰¾åˆ° ${audioInputs.length} å€‹éŸ³è¨Šè¨­å‚™ï¼Œç¾åœ¨å¯ä»¥é–‹å§‹ä½¿ç”¨éº¥å…‹é¢¨`;
        
      } catch (error) {
        console.error('éº¥å…‹é¢¨æ¸¬è©¦å¤±æ•—:', error);
        status.textContent = `âŒ éº¥å…‹é¢¨æ¸¬è©¦å¤±æ•—: ${error.message}`;
      }
    });
    
    // æ·»åŠ éŸ³é‡é–¾å€¼èª¿æ•´åŠŸèƒ½
    document.addEventListener('keydown', function(e) {
      if (e.key === 'ArrowUp') {
        volumeThreshold = Math.min(100, volumeThreshold + 5);
        console.log('éŸ³é‡é–¾å€¼:', volumeThreshold);
      } else if (e.key === 'ArrowDown') {
        volumeThreshold = Math.max(0, volumeThreshold - 5);
        console.log('éŸ³é‡é–¾å€¼:', volumeThreshold);
      }
    });
    
    // é»æ“Šä»»ä½•åœ°æ–¹é–‹å§‹éŒ„éŸ³
    document.addEventListener('click', function(e) {
      if (document.getElementById('clickToStart').style.display !== 'none') {
        autoStartMicrophone();
      }
    }, { once: true }); // åªåŸ·è¡Œä¸€æ¬¡
    
    // æ‡‰ç”¨å•Ÿå‹•æ™‚è‡ªå‹•è¼‰å…¥è¨“ç·´è³‡æ–™å’ŒèƒŒæ™¯è¨­å®š
    window.addEventListener('load', function() {
      // è¼‰å…¥è¨“ç·´è³‡æ–™
      if (loadTrainingDataFromLocal()) {
        console.log(`è‡ªå‹•è¼‰å…¥äº† ${trainingData.length} å€‹è¨“ç·´æ¨£æœ¬`);
        const trainingStatus = document.getElementById('trainingStatus');
        if (trainingStatus && trainingData.length > 0) {
          trainingStatus.textContent = `å·²è¼‰å…¥ ${trainingData.length} å€‹è¨“ç·´æ¨£æœ¬`;
          trainingStatus.style.color = '#4CAF50';
        }
      }
      
      // åˆå§‹åŒ–èƒŒæ™¯è¨­å®š
      initializeBackgroundSettings();
    });
    
    // ä¹Ÿå¯ä»¥æŒ‰ç©ºç™½éµé–‹å§‹
    document.addEventListener('keydown', function(e) {
      if (e.code === 'Space' && document.getElementById('clickToStart').style.display !== 'none') {
        e.preventDefault();
        autoStartMicrophone();
      }
    }, { once: true });
    
    // è¨“ç·´ç³»çµ±äº‹ä»¶è™•ç†å™¨
    document.getElementById('toggleTraining').addEventListener('click', function() {
      isTrainingMode = !isTrainingMode;
      const trainingInterface = document.getElementById('trainingInterface');
      const trainingStatus = document.getElementById('trainingStatus');
      const toggleBtn = document.getElementById('toggleTraining');
      
      if (isTrainingMode) {
        trainingInterface.style.display = 'block';
        trainingStatus.textContent = 'è¨“ç·´æ¨¡å¼å•Ÿç”¨ - æŒ‰ä½æŒ‰éˆ•ä¸¦ç™¼è²';
        trainingStatus.style.color = '#ff6b6b';
        toggleBtn.textContent = 'çµæŸè¨“ç·´æ¨¡å¼';
        toggleBtn.classList.add('training-active');
      } else {
        trainingInterface.style.display = 'none';
        trainingStatus.textContent = 'è¨“ç·´æ¨¡å¼é—œé–‰';
        trainingStatus.style.color = '#4ecdc4';
        toggleBtn.textContent = 'é–‹å§‹è¨“ç·´æ¨¡å¼';
        toggleBtn.classList.remove('training-active');
      }
    });
    
    // æ¸…é™¤è¨“ç·´è³‡æ–™
    document.getElementById('clearTrainingData').addEventListener('click', function() {
      if (confirm('ç¢ºå®šè¦æ¸…é™¤æ‰€æœ‰è¨“ç·´è³‡æ–™å—ï¼Ÿ')) {
        trainingData = [];
        updateTrainingCount();
        localStorage.removeItem('vtuberTrainingData'); // åŒæ™‚æ¸…é™¤æœ¬åœ°å„²å­˜
        console.log('è¨“ç·´è³‡æ–™å·²æ¸…é™¤');
      }
    });
    
    // å„²å­˜è¨“ç·´è³‡æ–™
    document.getElementById('saveTrainingData').addEventListener('click', function() {
      if (trainingData.length === 0) {
        alert('æ²’æœ‰è¨“ç·´è³‡æ–™å¯ä»¥å„²å­˜ï¼');
        return;
      }
      
      // é¡¯ç¤ºé¸é …ï¼šæœ¬åœ°å„²å­˜æˆ–æª”æ¡ˆåŒ¯å‡º
      const choice = confirm('é»æ“Šã€Œç¢ºå®šã€å„²å­˜åˆ°ç€è¦½å™¨æœ¬åœ°å„²å­˜\né»æ“Šã€Œå–æ¶ˆã€ä¸‹è¼‰ç‚ºæª”æ¡ˆ');
      
      if (choice) {
        // å„²å­˜åˆ°æœ¬åœ°å„²å­˜
        if (saveTrainingDataToLocal()) {
          alert(`æˆåŠŸå„²å­˜ ${trainingData.length} å€‹è¨“ç·´æ¨£æœ¬åˆ°æœ¬åœ°ï¼`);
        } else {
          alert('å„²å­˜å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦ï¼');
        }
      } else {
        // åŒ¯å‡ºç‚ºæª”æ¡ˆ
        if (exportTrainingData()) {
          alert('è¨“ç·´è³‡æ–™å·²ä¸‹è¼‰ç‚ºæª”æ¡ˆï¼');
        } else {
          alert('åŒ¯å‡ºå¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦ï¼');
        }
      }
    });
    
    // è¼‰å…¥è¨“ç·´è³‡æ–™
    document.getElementById('loadTrainingData').addEventListener('click', function() {
      // é¡¯ç¤ºé¸é …ï¼šæœ¬åœ°è¼‰å…¥æˆ–æª”æ¡ˆåŒ¯å…¥
      const choice = confirm('é»æ“Šã€Œç¢ºå®šã€å¾ç€è¦½å™¨æœ¬åœ°å„²å­˜è¼‰å…¥\né»æ“Šã€Œå–æ¶ˆã€å¾æª”æ¡ˆåŒ¯å…¥');
      
      if (choice) {
        // å¾æœ¬åœ°å„²å­˜è¼‰å…¥
        if (loadTrainingDataFromLocal()) {
          alert(`æˆåŠŸè¼‰å…¥ ${trainingData.length} å€‹è¨“ç·´æ¨£æœ¬ï¼`);
        } else {
          alert('æ²’æœ‰æ‰¾åˆ°æœ¬åœ°å„²å­˜çš„è¨“ç·´è³‡æ–™ï¼');
        }
      } else {
        // å¾æª”æ¡ˆåŒ¯å…¥
        importTrainingData();
      }
    });
    
    // å˜´å‹æŒ‰éˆ•äº‹ä»¶ - æ”¹ç‚ºæŒ‰ä½éŒ„éŸ³æ¨¡å¼
    document.querySelectorAll('.mouth-btn').forEach(btn => {
      // æŒ‰ä¸‹é–‹å§‹éŒ„éŸ³
      btn.addEventListener('mousedown', function(e) {
        e.preventDefault();
        if (!isTrainingMode) {
          alert('è«‹å…ˆå•Ÿç”¨è¨“ç·´æ¨¡å¼ï¼');
          return;
        }
        
        const mouthType = this.getAttribute('data-mouth');
        startRecording(this, mouthType);
      });
      
      // æ”¾é–‹åœæ­¢éŒ„éŸ³
      btn.addEventListener('mouseup', function(e) {
        e.preventDefault();
        stopRecording();
      });
      
      // æ»‘é¼ é›¢é–‹ä¹Ÿåœæ­¢éŒ„éŸ³
      btn.addEventListener('mouseleave', function(e) {
        if (currentRecordingButton === this) {
          stopRecording();
        }
      });
      
      // æ”¯æ´è§¸æ§è¨­å‚™
      btn.addEventListener('touchstart', function(e) {
        e.preventDefault();
        if (!isTrainingMode) {
          alert('è«‹å…ˆå•Ÿç”¨è¨“ç·´æ¨¡å¼ï¼');
          return;
        }
        
        const mouthType = this.getAttribute('data-mouth');
        startRecording(this, mouthType);
      });
      
      btn.addEventListener('touchend', function(e) {
        e.preventDefault();
        stopRecording();
      });
    });
    
    // é–‹å§‹éŒ„éŸ³
    function startRecording(button, mouthType) {
      if (currentRecordingButton) return; // é˜²æ­¢é‡è¤‡éŒ„éŸ³
      
      currentRecordingButton = button;
      recordingBuffer = [];
      recordingStartTime = Date.now();
      
      // è¦–è¦ºå›é¥‹
      button.classList.add('pressed');
      button.textContent = `ğŸ”´ éŒ„éŸ³ä¸­...`;
      
      // é–‹å§‹æ”¶é›†éŸ³è¨Šè³‡æ–™
      recordingTimer = setInterval(() => {
        if (currentAudioFeatures) {
          recordingBuffer.push([...currentAudioFeatures]);
        }
      }, 50); // æ¯ 50ms æ”¶é›†ä¸€æ¬¡
      
      console.log(`é–‹å§‹éŒ„éŸ³: ${mouthType}`);
    }

    // åœæ­¢éŒ„éŸ³
    function stopRecording() {
      if (!currentRecordingButton) return;
      
      const mouthType = currentRecordingButton.getAttribute('data-mouth');
      const recordingDuration = Date.now() - recordingStartTime;
      
      // æ¸…é™¤å®šæ™‚å™¨
      if (recordingTimer) {
        clearInterval(recordingTimer);
        recordingTimer = null;
      }
      
      // æ¢å¾©æŒ‰éˆ•ç‹€æ…‹
      currentRecordingButton.classList.remove('pressed');
      const originalText = {
        'a': 'A (å•Š)',
        'e': 'E (æ¬¸)', 
        'i': 'I (å’¿)',
        'o': 'O (å–”)',
        'u': 'U (å—š)',
        'close': 'é–‰å˜´'
      };
      currentRecordingButton.textContent = originalText[mouthType];
      
      // è™•ç†éŒ„éŸ³è³‡æ–™
      if (recordingBuffer.length > 0 && recordingDuration >= 200) {
        // è¨ˆç®—å¹³å‡ç‰¹å¾µ
        const avgFeatures = calculateAverageFeatures(recordingBuffer);
        
        // æ·»åŠ è¨“ç·´è³‡æ–™
        trainingData.push({
          features: avgFeatures,
          label: mouthType,
          duration: recordingDuration,
          samples: recordingBuffer.length
        });
        
        updateTrainingCount();
        autoSaveTrainingData();
        
        console.log(`éŒ„éŸ³å®Œæˆ: ${mouthType}, æ™‚é•·: ${recordingDuration}ms, æ¨£æœ¬æ•¸: ${recordingBuffer.length}`);
        
        // æˆåŠŸå›é¥‹
        currentRecordingButton.classList.add('recording');
        setTimeout(() => {
          currentRecordingButton.classList.remove('recording');
        }, 500);
        
      } else {
        console.log('éŒ„éŸ³æ™‚é–“å¤ªçŸ­æˆ–æ²’æœ‰éŸ³è¨Šè³‡æ–™');
        alert('éŒ„éŸ³æ™‚é–“å¤ªçŸ­ï¼è«‹æŒ‰ä½æŒ‰éˆ•è‡³å°‘ 0.2 ç§’ä¸¦ç™¼å‡ºè²éŸ³ã€‚');
      }
      
      currentRecordingButton = null;
      recordingBuffer = [];
    }

    // è¨ˆç®—å¹³å‡ç‰¹å¾µ
    function calculateAverageFeatures(buffer) {
      if (buffer.length === 0) return [];
      
      const featureCount = buffer[0].length;
      const avgFeatures = new Array(featureCount).fill(0);
      
      // è¨ˆç®—æ¯å€‹ç‰¹å¾µçš„å¹³å‡å€¼
      buffer.forEach(features => {
        features.forEach((value, index) => {
          avgFeatures[index] += value;
        });
      });
      
      return avgFeatures.map(sum => sum / buffer.length);
    }
    
    // æ›´æ–°è¨“ç·´è¨ˆæ•¸é¡¯ç¤º
    function updateTrainingCount() {
      const countElement = document.getElementById('trainingCount');
      if (countElement) {
        countElement.textContent = trainingData.length;
        
        // é¡¯ç¤ºå„å˜´å‹çš„æ¨£æœ¬æ•¸é‡
        const counts = {};
        trainingData.forEach(sample => {
          counts[sample.label] = (counts[sample.label] || 0) + 1;
        });
        
        const breakdown = Object.keys(counts)
          .map(label => `${label}:${counts[label]}`)
          .join(', ');
        
        countElement.title = breakdown || 'ç„¡è³‡æ–™';
      }
    }
    
    // å„²å­˜è¨“ç·´è³‡æ–™åˆ°æœ¬åœ°å„²å­˜
    function saveTrainingDataToLocal() {
      try {
        const dataToSave = {
          version: '1.0',
          timestamp: new Date().toISOString(),
          trainingData: trainingData,
          totalSamples: trainingData.length
        };
        
        localStorage.setItem('vtuberTrainingData', JSON.stringify(dataToSave));
        return true;
      } catch (error) {
        console.error('å„²å­˜è¨“ç·´è³‡æ–™å¤±æ•—:', error);
        return false;
      }
    }
    
    // å¾æœ¬åœ°å„²å­˜è¼‰å…¥è¨“ç·´è³‡æ–™
    function loadTrainingDataFromLocal() {
      try {
        const savedData = localStorage.getItem('vtuberTrainingData');
        if (savedData) {
          const parsedData = JSON.parse(savedData);
          if (parsedData.version && parsedData.trainingData) {
            trainingData = parsedData.trainingData;
            updateTrainingCount();
            return true;
          }
        }
        return false;
      } catch (error) {
        console.error('è¼‰å…¥è¨“ç·´è³‡æ–™å¤±æ•—:', error);
        return false;
      }
    }
    
    // åŒ¯å‡ºè¨“ç·´è³‡æ–™ç‚ºæª”æ¡ˆ
    function exportTrainingData() {
      try {
        const dataToExport = {
          version: '1.0',
          timestamp: new Date().toISOString(),
          trainingData: trainingData,
          totalSamples: trainingData.length,
          description: 'VTuberèªéŸ³è¨“ç·´è³‡æ–™'
        };
        
        const jsonString = JSON.stringify(dataToExport, null, 2);
        const blob = new Blob([jsonString], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = `vtuber_training_data_${new Date().toISOString().slice(0, 10)}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        return true;
      } catch (error) {
        console.error('åŒ¯å‡ºè¨“ç·´è³‡æ–™å¤±æ•—:', error);
        return false;
      }
    }
    
    // åŒ¯å…¥è¨“ç·´è³‡æ–™æª”æ¡ˆ
    function importTrainingData() {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.json';
      
      input.onchange = function(event) {
        const file = event.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = function(e) {
            try {
              const importedData = JSON.parse(e.target.result);
              if (importedData.version && importedData.trainingData) {
                if (confirm(`ç¢ºå®šè¦è¼‰å…¥ ${importedData.totalSamples} å€‹è¨“ç·´æ¨£æœ¬å—ï¼Ÿé€™æœƒè¦†è“‹ç¾æœ‰çš„è¨“ç·´è³‡æ–™ã€‚`)) {
                  trainingData = importedData.trainingData;
                  updateTrainingCount();
                  saveTrainingDataToLocal(); // è‡ªå‹•å„²å­˜åˆ°æœ¬åœ°
                  alert('è¨“ç·´è³‡æ–™è¼‰å…¥æˆåŠŸï¼');
                }
              } else {
                alert('ç„¡æ•ˆçš„è¨“ç·´è³‡æ–™æª”æ¡ˆæ ¼å¼ï¼');
              }
            } catch (error) {
              console.error('åŒ¯å…¥è¨“ç·´è³‡æ–™å¤±æ•—:', error);
              alert('åŒ¯å…¥å¤±æ•—ï¼šæª”æ¡ˆæ ¼å¼éŒ¯èª¤ï¼');
            }
          };
          reader.readAsText(file);
        }
      };
      
      input.click();
    }
    
    // è‡ªå‹•å„²å­˜è¨“ç·´è³‡æ–™
    function autoSaveTrainingData() {
      if (trainingData.length > 0) {
        saveTrainingDataToLocal();
        console.log('è¨“ç·´è³‡æ–™å·²è‡ªå‹•å„²å­˜');
      }
    }
    
    // èƒŒæ™¯è¨­å®šç›¸é—œè®Šæ•¸
    let currentBgStyle = 'solid';
    let currentBgColor = '#000000';
    let currentBgGradientColor = '#333333';
    let currentBgOpacity = 100;
    
    // åˆå§‹åŒ–èƒŒæ™¯è¨­å®š
    function initializeBackgroundSettings() {
      const bgColorPicker = document.getElementById('bgColorPicker');
      const bgGradientColor = document.getElementById('bgGradientColor');
      const bgOpacitySlider = document.getElementById('bgOpacitySlider');
      const bgOpacityValue = document.getElementById('bgOpacityValue');
      const resetBgColor = document.getElementById('resetBgColor');
      const bgStyleButtons = document.querySelectorAll('.bg-style-btn');
      const gradientControls = document.getElementById('gradientControls');
      
      // è¼‰å…¥å„²å­˜çš„è¨­å®š
      loadBackgroundSettings();
      
      // é¡è‰²é¸æ“‡å™¨äº‹ä»¶
      bgColorPicker.addEventListener('change', function(e) {
        currentBgColor = e.target.value;
        updateVTuberBackground();
        saveBackgroundSettings();
      });
      
      // æ¼¸å±¤é¡è‰²é¸æ“‡å™¨äº‹ä»¶
      bgGradientColor.addEventListener('change', function(e) {
        currentBgGradientColor = e.target.value;
        if (currentBgStyle === 'gradient') {
          updateVTuberBackground();
          saveBackgroundSettings();
        }
      });
      
      // ä¸é€æ˜åº¦æ»‘æ¡¿äº‹ä»¶
      bgOpacitySlider.addEventListener('input', function(e) {
        currentBgOpacity = parseInt(e.target.value);
        bgOpacityValue.textContent = currentBgOpacity + '%';
        updateVTuberBackground();
        saveBackgroundSettings();
      });
      
      // é‡ç½®æŒ‰éˆ•äº‹ä»¶
      resetBgColor.addEventListener('click', function() {
        currentBgColor = '#000000';
        currentBgGradientColor = '#333333';
        currentBgOpacity = 100;
        currentBgStyle = 'solid';
        
        bgColorPicker.value = currentBgColor;
        bgGradientColor.value = currentBgGradientColor;
        bgOpacitySlider.value = currentBgOpacity;
        bgOpacityValue.textContent = currentBgOpacity + '%';
        
        // æ›´æ–°æ¨£å¼æŒ‰éˆ•
        bgStyleButtons.forEach(btn => btn.classList.remove('active'));
        document.querySelector('[data-style="solid"]').classList.add('active');
        gradientControls.style.display = 'none';
        
        updateVTuberBackground();
        saveBackgroundSettings();
      });
      
      // èƒŒæ™¯æ¨£å¼æŒ‰éˆ•äº‹ä»¶
      bgStyleButtons.forEach(btn => {
        btn.addEventListener('click', function() {
          bgStyleButtons.forEach(b => b.classList.remove('active'));
          this.classList.add('active');
          
          currentBgStyle = this.getAttribute('data-style');
          
          // é¡¯ç¤ºæˆ–éš±è—æ¼¸å±¤æ§åˆ¶é …
          if (currentBgStyle === 'gradient') {
            gradientControls.style.display = 'flex';
          } else {
            gradientControls.style.display = 'none';
          }
          
          updateVTuberBackground();
          saveBackgroundSettings();
        });
      });
      
      // åˆå§‹åŒ–èƒŒæ™¯
      updateVTuberBackground();
    }
    
    // æ›´æ–° VTuber èƒŒæ™¯
    function updateVTuberBackground() {
      const vtuberImage = document.getElementById('vtuberImage');
      const opacity = currentBgOpacity / 100;
      
      let background;
      
      switch (currentBgStyle) {
        case 'solid':
          background = currentBgColor;
          break;
        case 'gradient':
          background = `linear-gradient(135deg, ${currentBgColor}, ${currentBgGradientColor})`;
          break;
        case 'transparent':
          background = 'transparent';
          break;
        default:
          background = currentBgColor;
      }
      
      // å¦‚æœæ˜¯é€æ˜æ¨¡å¼ï¼Œå¿½ç•¥ä¸é€æ˜åº¦è¨­å®š
      if (currentBgStyle === 'transparent') {
        vtuberImage.style.background = background;
      } else {
        // å°‡ä¸é€æ˜åº¦æ‡‰ç”¨åˆ°èƒŒæ™¯
        if (currentBgStyle === 'solid') {
          const rgb = hexToRgb(currentBgColor);
          if (rgb) {
            background = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
          }
        } else if (currentBgStyle === 'gradient') {
          const rgb1 = hexToRgb(currentBgColor);
          const rgb2 = hexToRgb(currentBgGradientColor);
          if (rgb1 && rgb2) {
            background = `linear-gradient(135deg, rgba(${rgb1.r}, ${rgb1.g}, ${rgb1.b}, ${opacity}), rgba(${rgb2.r}, ${rgb2.g}, ${rgb2.b}, ${opacity}))`;
          }
        }
        vtuberImage.style.background = background;
      }
      
      console.log('èƒŒæ™¯å·²æ›´æ–°:', background);
    }
    
    // å°‡ hex é¡è‰²è½‰æ›ç‚º RGB
    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
      } : null;
    }
    
    // å„²å­˜èƒŒæ™¯è¨­å®š
    function saveBackgroundSettings() {
      try {
        const settings = {
          style: currentBgStyle,
          color: currentBgColor,
          gradientColor: currentBgGradientColor,
          opacity: currentBgOpacity
        };
        localStorage.setItem('vtuberBackgroundSettings', JSON.stringify(settings));
      } catch (error) {
        console.error('å„²å­˜èƒŒæ™¯è¨­å®šå¤±æ•—:', error);
      }
    }
    
    // è¼‰å…¥èƒŒæ™¯è¨­å®š
    function loadBackgroundSettings() {
      try {
        const saved = localStorage.getItem('vtuberBackgroundSettings');
        if (saved) {
          const settings = JSON.parse(saved);
          currentBgStyle = settings.style || 'solid';
          currentBgColor = settings.color || '#000000';
          currentBgGradientColor = settings.gradientColor || '#333333';
          currentBgOpacity = settings.opacity || 100;
          
          // æ›´æ–° UI
          document.getElementById('bgColorPicker').value = currentBgColor;
          document.getElementById('bgGradientColor').value = currentBgGradientColor;
          document.getElementById('bgOpacitySlider').value = currentBgOpacity;
          document.getElementById('bgOpacityValue').textContent = currentBgOpacity + '%';
          
          // æ›´æ–°æ¨£å¼æŒ‰éˆ•
          document.querySelectorAll('.bg-style-btn').forEach(btn => {
            btn.classList.remove('active');
            if (btn.getAttribute('data-style') === currentBgStyle) {
              btn.classList.add('active');
            }
          });
          
          // é¡¯ç¤ºæˆ–éš±è—æ¼¸å±¤æ§åˆ¶é …
          const gradientControls = document.getElementById('gradientControls');
          if (currentBgStyle === 'gradient') {
            gradientControls.style.display = 'flex';
          } else {
            gradientControls.style.display = 'none';
          }
        }
      } catch (error) {
        console.error('è¼‰å…¥èƒŒæ™¯è¨­å®šå¤±æ•—:', error);
      }
    }
  </script>
</body>
</html>